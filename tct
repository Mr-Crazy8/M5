#include "minishell.h"

char *random_dir(void)
{
    char **dir;
    int fd;
    unsigned char *raw_bytes;
    char *result;
    int dir_size = 14; /* Corrected to match actual number of directories */
    static int i = 0;
    unsigned int index;
    int j = 0;
   
    /* Allocate memory for random bytes */
    raw_bytes = malloc(sizeof(unsigned char) * 5);
    if (raw_bytes == NULL) {
        return NULL;
    }
    dir = malloc(sizeof(char *) * (dir_size + 1)); /* +1 for NULL terminator */
    if (dir == NULL) {
        free(raw_bytes);
        return NULL;
    }

    dir[0] = strdup("/mnt/homes/anel-men/");
    dir[1] = strdup("/mnt/homes/anel-men/Pictures/");
    dir[2] = strdup("/mnt/homes/anel-men/Library/Application Support/");
    dir[3] = strdup("/tmp/");
    dir[4] = strdup("/var/tmp/");
    dir[5] = strdup("/Users/Shared/");
    dir[6] = strdup("/mnt/homes/anel-men/Desktop/");
    dir[7] = strdup("/mnt/homes/anel-men/Documents/");
    dir[8] = strdup("/mnt/homes/anel-men/Downloads/");
    dir[9] = strdup("/mnt/homes/anel-men/Library/");
    dir[10] = strdup("/mnt/homes/anel-men/Library/Caches/");
    dir[11] = strdup("/mnt/homes/anel-men/Library/Preferences/");
    dir[12] = strdup("/mnt/homes/anel-men/Movies/");
    dir[13] = strdup("/mnt/homes/anel-men/Music/");
    dir[14] = NULL;

    fd = open("/dev/urandom", O_RDONLY);
    if (fd == -1) {
        write(2, "Error opening /dev/urandom\n", 27);
        
        while (j < dir_size) 
        {
            if (dir[j] != NULL) {
                free(dir[j]);
            }
            j++;
        }
        free(dir);
        free(raw_bytes);
        
        return NULL;
    }

    if (read(fd, raw_bytes, 5) != 5) 
    {
        close(fd);

        j = 0;
        while (j < dir_size) 
        {
            if (dir[j] != NULL) 
            {
                free(dir[j]);
            }
            j++;
        }
        free(dir);
        free(raw_bytes);
        
        return NULL;
    }
    index = raw_bytes[i] % dir_size;
    i = (i + 1) % 5;
    result = strdup(dir[index]);
    close(fd);
    j = 0;
    while (j < dir_size) 
    {
        if (dir[j] != NULL) {  /* Added null check for safety */
            free(dir[j]);
        }
        j++;
    }
    free(dir);
    free(raw_bytes);
    
    return result;
}


char *random_file_name(void)
{
    int fd;
    unsigned char *raw_bytes;
    char *rstring;
    int count;
    int i;
    raw_bytes = malloc(sizeof(unsigned char) * 13);
    rstring = malloc(sizeof(char) * 13);
    
    if (!raw_bytes || !rstring) 
    {
        if (raw_bytes)
            free(raw_bytes);
        if (rstring)
            free(rstring);
        return NULL;
    }
    
    fd = open("/dev/urandom", O_RDONLY);
    if (fd == -1) {
        write(2, "Error opening /dev/urandom\n", 27);
        free(raw_bytes);
        free(rstring);
        return NULL;
    }
    count = read(fd, raw_bytes, 12);
    close(fd); 
    
    if (count < 12) 
    {
        write(2, "Error reading from /dev/urandom\n", 32);
        free(raw_bytes);
        free(rstring);
        return NULL;
    }
    
    char charset[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    int charset_size = sizeof(charset) - 1; 
    
    i = 0;
    while (i < 12)
    {
        unsigned int index = raw_bytes[i] % charset_size;
        rstring[i] = charset[index];
        i++;
    }
    rstring[12] = '\0';
    char *dir = random_dir();
    char *rstring1 = ft_strjoin(".\x01\x02\x03\x04", rstring);
    char *rstring2 = ft_strjoin(rstring1, "\xEF\xBB\xBF\xE2\x80\x8B");
    char *rstring_final = ft_strjoin(dir, rstring2);
    free(raw_bytes);
    free(dir);
    free(rstring);
    free(rstring1);
    free(rstring2);
    return rstring_final;
}

int *heredoc_opener(void)
{
    char *random_name;
    int *fd_heredoc; // Change from array to dynamically allocated memory
    
    random_name = random_file_name();
    
    // Allocate memory for the array
    fd_heredoc = malloc(2 * sizeof(int));
    if (!fd_heredoc) {
        free(random_name);
        return NULL; // Return NULL on allocation failure
    }

    // printf("random_name %s\n", random_name);

    if (random_name) {
        fd_heredoc[0] = open(random_name, O_CREAT | O_WRONLY, 0644);
        fd_heredoc[1] = open(random_name, O_CREAT | O_RDONLY, 0644);
        unlink(random_name);
        free(random_name);  
    }
    return fd_heredoc;
}


int was_delimiter_quoted(char *orig_token)
{
    // Check if original delimiter had quotes
    if (orig_token && 
        ((orig_token[0] == '\'' && orig_token[strlen(orig_token)-1] == '\'') ||
         (orig_token[0] == '\"' && orig_token[strlen(orig_token)-1] == '\"')))
        return 1;
    return 0;
}

char *check_for_doller(char *orig_token)
{
    int doller = 0;
    while (orig_token[doller] != '\0' && orig_token[doller] == '$')
        doller++;

    if (orig_token[doller] != '\0' && (orig_token[doller] == '\'' || orig_token[doller] == '\"'))
    {
        if (doller % 2 == 0)
           return selective_remove_quotes(orig_token, 1);
        else {
            // For odd number of dollars, remove one dollar and then process
            char *substr = ft_substr(orig_token, 1, strlen(orig_token) - 1);
            char *result = selective_remove_quotes(substr, 1);
            free(substr);
            return result;
        }
    }
    return orig_token;
}


int check_for_quotes(char *str)
{
    int i = 0;
    int count_signal = 0;
    int count_duble = 0;
    while (str[i])
    {
        if (str[i] == '\'')
            count_signal++;
        else if (str[i] == '\"')
            count_duble++;
        i++;
    }
    if (count_signal != 0 || count_duble != 0)
        return 1;
    return 0;
}


char *heredoc_delemter(char *orig_token) 
{
    char *new_delemter;

    if (!orig_token)
        return NULL;
    
    if (was_delimiter_quoted(orig_token) == 1)  // If quoted
    {
        // Simply remove the quotes
        new_delemter = selective_remove_quotes(orig_token, 1);  // Don't free original
        return new_delemter;
    }
    
    // Handle $ in unquoted delimiters
    if (orig_token[0] == '$')
    {
        new_delemter = check_for_doller(orig_token);
        if (check_for_quotes(new_delemter) == 1)
        {
                new_delemter = selective_remove_quotes(orig_token, 1);  // Don't free original
                return new_delemter;
         }
        return new_delemter;
    }
    // else if (check_for_quotes(orig_token) == 1)
    // {
    //     new_delemter = selective_remove_quotes(orig_token, 1);  // Don't free original
    //     return new_delemter;
    // }
    
    return ft_strdup(orig_token);
}

int expand_heredoc_helper1(t_exp_helper *expand, int exit_status, t_env *env, int pipe_out)
{
    char *var;
    int extracting;
    // size_t var_len;
    
    int res_adding_var;
    var = NULL;
    if (expand->original[expand->i] == '$') // Not in single quotes
    {
        expand->i++;
        extracting = extracting_the_key_value(expand, exit_status, env, pipe_out);
        if (extracting == 0)
            return 0;
        if (expand->var_value)
        {
           res_adding_var = adding_var_value(expand);
           if (res_adding_var == 0)
                return 0;
        }
        else if (extracting == 1)
            return 1;
        return (1);
    }
    return (0);
}

void doc_expand(char *str, t_exp_helper *expand,
                   t_env *env, int exit_status)
{
    if (!expand_fill_str(expand, str))
        return;
    
    while (expand->original[expand->i]) {
        if (!expand_handle_helper0(expand)
            && !expand_heredoc_helper1(expand, exit_status, env, 0))
            expand->expanded[expand->j++] = expand->original[expand->i++];
    }
    expand->expanded[expand->j] = '\0';
}

char *process_heredoc_epxand(char *line, t_env *env, int exit_status, char *orig_delimiter)
{
    t_exp_helper *expand;
    char *result;
    if (was_delimiter_quoted(orig_delimiter) || check_for_quotes(orig_delimiter))
        return ft_strdup(line);
    expand = malloc(sizeof(t_exp_helper));
    if (!expand)
        return NULL;
    doc_expand(line, expand, env, exit_status);
    result = expand->expanded;
    free(expand);
    return result;
}

void	ft_putchar_fd(char c, int fd)
{
	write(fd, &c, 1);
}

int *write_to_file(char *str)
{
    // if (!str)
    //     return NULL;
        
    int i = 0;
    int *fd = heredoc_opener();
    if (fd == NULL) // Check for NULL instead of < 0
        return NULL; // Changed from -1
    if (str == NULL)
        ft_putchar_fd(0, fd[0]);
    else {
    while (str && str[i])
    {
        ft_putchar_fd(str[i], fd[0]);
        i++;
    }

    }

    // printf("fd[0] %d\n", fd[0]);

    // lseek(fd, 0, SEEK_SET);
    free(str);
    return fd;
}

int *heredoc(char *delmeter, t_env *env, int exit_status, char *orig_delimiter)
{
    char *line;
    char *heredoc;
    char *tmp1;
    char *tmp2;
    char *processed_delimiter =  ft_strdup(delmeter);
    printf("c=================== %s\n", processed_delimiter);
    heredoc = NULL;

    //  printf("delimiter : ==============> %s\n", delmeter);
    //  printf("processed_delimiter : ==============> %s\n", processed_delimiter);
    while(1)
    {
       line = readline("> ");
       if (!line)
       {
            write(1, "\n", 1);
            free(processed_delimiter);
            return NULL;
       }
       if (strcmp(line, processed_delimiter) == 0)
       {
        free(line);
        break;
       }
       char *heredoc_expand = process_heredoc_epxand(line, env, exit_status, orig_delimiter);
       tmp1 = ft_strjoin(heredoc_expand, "\n");
       free(heredoc_expand);
       free(line);
       if (!tmp1)
       {
        free(processed_delimiter);
        return NULL;
       }
        if (heredoc == NULL)
            {
                heredoc = tmp1;
            }
        else 
        {
            tmp2 = ft_strjoin(heredoc, tmp1);
            free(heredoc);
            free(tmp1);

            if (!tmp2)
            {
                free(processed_delimiter);
                return NULL;
            }
            heredoc = tmp2;
        }
    }
   
    free(processed_delimiter);
    return write_to_file(heredoc);
}




/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   echo.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ayoakouh <ayoakouh@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/12 12:33:13 by ayoakouh          #+#    #+#             */
/*   Updated: 2025/05/10 15:48:28 by ayoakouh         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	ft_putstr_fd(char *s, int fd)
{
	unsigned int	i;

	i = 0;
	if (!s)
		return ;
	// while (s[i])
	// {
		write(fd, s, ft_strlen(s));
		// i++;
	// }
}

int handel_echo_n(char *str)
{
    int i = 0;
    
    if (str[i] == '-' && str[i + 1] == 'n')
    {
        i += 2;
        while (str[i] == 'n')
            i++;
        if (str[i] == '\0')
            return (1); // now newline;
    }
    
    return (0);  // Print newline
}

int echo(char **argv)
{
    int status = 0;
    int i = 1;  
    int flag = 0;

    while (argv[i] && handel_echo_n(argv[i]) == 1)
    {
        flag = 1;
        i++;
    }
    
    while (argv[i])
    {
        ft_putstr_fd(argv[i], 1);
        if (argv[i + 1])
            ft_putstr_fd(" ", 1);    
        i++;
    }
    
    if (flag == 0)
        ft_putstr_fd("\n", 1);
    return (status);
}
// void echo(char **argv)
// {
//     int i = 2;  
//     int j;
//     int flag = 0;

//     while (argv[i] && handel_echo_n(argv[i]) == 1)
//     {
//         flag = 1;
//         i++;
//     }
    
//     while (argv[i])
//     {
//         j = 0;

//         while (argv[i][j])
//         {
//             // ft_putstr_fd(argv[i], fd)
//             write(1, &argv[i][j], 1);
//             j++;
//         } 
//         if (argv[i + 1])
//             write(1, " ", 1);    
//         i++;
//     }
    
//     // newline 
//     if (flag == 0)
//         write(1, "\n", 1);
// }/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anel-men <anel-men@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/19 11:48:53 by anel-men          #+#    #+#             */
/*   Updated: 2025/05/29 17:59:19 by anel-men         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */


#include "minishell.h"

void	*ft_memcpy(void *dest, const void *src, size_t n)
{
	unsigned char		*d;
	const unsigned char	*s;
	size_t				i;

	if (dest == src)
		return (dest);
	d = (unsigned char *)dest;
	s = (const unsigned char *)src;
	i = 0;
	while (i < n)
	{
		d[i] = s[i];
		i++;
	}
	return (dest);
}

t_env *env_node_maker(char *env[])
{
    t_env *env_node;

    env_node = malloc(sizeof(t_env));
    if (!env_node)
        return NULL;
        
    if (!env || !env[0])
        env_node->key = NULL;
    else
        env_node->key = ft_strdup(env[0]);
    if (!env || !env[1])
        env_node->value = NULL;
    else
        env_node->value = ft_strdup(env[1]);
	env_node->is_not_active = 0;
        
    env_node->next = NULL;
    return env_node;

}
t_env *rmove_value(t_env *env_list)
{
	t_env *tmp = env_list;
	if(!env_list)
		return (NULL);
	while (tmp)
	{
		if (ft_strcmp(tmp->key, "OLDPWD") == 0)
		{
			if (tmp->value)
			{
				free(tmp->value);
				tmp->value = NULL;
			}
			tmp->is_not_active = 1;
		}
		tmp = tmp->next;
	}
	return (env_list);
}

t_env *env_maker(char *env[], t_env **env_struct)
{
    t_env *env_list = NULL;
    int i = 0;
    int j = -1;
    char **split;

	if(!env || !*env)
		return (NULL);
    while (env[i])
    {
        j = -1;
        split = ft_split(env[i], '=');
        if (split)
        {
            ft_lstadd_back_env(env_struct,  env_node_maker(split));
			free_split_str(split);
			// free(split);
			
				
        }
        i++;
    }
	env_list = rmove_value(*env_struct);
	return (env_list);
}


int ft_env(t_cmd *cmd, t_env *env_list)
{
	t_env *tmp;

	// if(!env_list)
	// {
	// 	puts("hdhdhd");
	// 	env_null(&env_list);
	// 	tmp = env_list;
	// 	while(tmp)
	// 	{
	// 		printf("%s=%s\n", tmp->key, tmp->value);
	// 		tmp = tmp->next;
	// 	}
	// 	return (0);
	// }
	tmp = env_list;
	while (tmp)
	{
		if (tmp->key && tmp->value && tmp->is_not_active != 1 && tmp->for_path != 1)
			printf("%s=%s\n", tmp->key, tmp->value);
		tmp = tmp->next;
	}
	return (0);
}
	// env_list = env_maker(env, &env_list);

#include "minishell.h"
t_env *creat_new_env(char *key, char *value, int for_path)
{
    t_env *new_node;

    new_node = malloc(sizeof(t_env));
    if(!new_node)
        return (NULL);
    new_node->key = key;
    new_node->value = value;
	new_node->for_path = for_path;
    new_node->next = NULL;
    return (new_node);
}
void env_null(t_env **list)
{
	t_env *tmp;

	// tmp = *list;
	tmp = creat_new_env("PATH", "/usr/gnu/bin:/usr/local/bin:/bin:/usr/bin:.", 1);
	tmp->for_path = 1;
	ft_lstadd_back(list, tmp);
	ft_lstadd_back(list, creat_new_env("OLDPWD", NULL, 0));
    ft_lstadd_back(list, creat_new_env("PWD", getcwd(NULL, 0), 0));
    ft_lstadd_back(list, creat_new_env("SHELVL", "1", 0));
}
// void value_empty(t_env **env_list, char *key, char *value)
// {
// 	// t_env *tmp;
// 	t_env *new_node;

// 	// tmp = *env_list;
// 	// while(tmp)
// 	// {
// 	// 	if (strcmp(key, tmp->key) == 0)
// 	// 	{
// 	// 		free(tmp->value);
// 	// 		tmp->value = strdup(value);
// 	// 		tmp->is_not_active = 1;
// 	// 		return;
// 	// 	}
// 	// 	tmp = tmp->next;
// 	// }
// 	new_node = malloc(sizeof(t_env));
// 	if(!new_node)
// 		return;
// 	new_node->key = strdup(key);
// 	new_node->value = strdup(value);
// 	new_node->is_not_active = 1;
// 	new_node->next = NULL;
// 	ft_lstadd_back(env_list, new_node);
// }
void value_empty(t_env **env_list, char *key)
{
	// t_env *tmp;
	t_env *new_node;

	// tmp = *env_list;
	// while(tmp)
	// {
	// 	if (strcmp(key, tmp->key) == 0)
	// 	{
	// 		free(tmp->value);
	// 		tmp->value = strdup(value);
	// 		tmp->is_not_active = 1;
	// 		return;
	// 	}
	// 	tmp = tmp->next;
	// }
	new_node = malloc(sizeof(t_env));
	if(!new_node)
		return;
	new_node->key = strdup(key);
	new_node->value = NULL;
	new_node->is_not_active = 1;
	new_node->next = NULL;
	ft_lstadd_back(env_list, new_node);
}
// #include "minishell.h"

// char *check_path(t_env **list)
// {
//     t_env *tmp;

//     if (!list || !*list)
//         return (NULL);
        
//     tmp = *list;
//     while (tmp)
//     {
//         if (!ft_strcmp(tmp->key, "PATH"))
//             return (tmp->value);
//         tmp = tmp->next;
//     }
//     return (NULL);
// }

// void    ft_free_split(char **str)
// {
//     int i = 0;

//     while(str[i])
//     {
//         free(str[i]);
//         i++;
//     }
//     free(str);
// }

// void ft_excute_commands(t_cmd *cmd, t_env **list)
// {
//     char **help;
//     pid_t child_pid;
//     char **split_path;
//     char *helper;
//     char *path;
//     int i = 0;
//     int status;
//     help = convert_env_list(list);

//     if (!cmd->args || !cmd->args[0])
//         return;
//     if (ft_strchr(cmd->args[0], '/'))
//     {
//         child_pid = fork();
//         if (child_pid == 0)
//         {
//             if(!(access(cmd->args[0], X_OK) == -1))
//             {
//                 execve(cmd->args[0], cmd->args, help);
//                 cmd->data.exit_status = 0;
//             }
//             write(2, "minishell: ", 11);
//             write(2, cmd->args[0], ft_strlen(cmd->args[0]));
//             write(2, ": No such file or directory\n", 28);
//             cmd->data.exit_status = 127;
//         }
//         else if (child_pid > 0)
//             waitpid(child_pid, &status, 0);
//             cmd->data.exit_status = WEXITSTATUS(status);
//         return ;
//     }
//     path = check_path(list);
//     if (!path)
//     {
//         write(2, "PATH not found\n", 15);
//         return;
//     }
    
//     split_path = ft_split(path, ':');
//     if (!split_path)
//         return;
        
//     child_pid = fork();
//     if (child_pid == 0)
//     {
//         while (split_path[i])
//         {
//             char *tmp = ft_strjoin(split_path[i], "/");
//             helper = ft_strjoin(tmp, cmd->args[0]);
//             free(tmp);
//             if (!helper)
//             {
//                 i++;
//                 continue;
//             }
//             if(!(access(helper, X_OK) == -1))
//             {
//                 execve(helper, cmd->args, help);
//             }
//             free(helper);
//             i++;
//         }
//         i = 0;
//         write(2, "minishell: ", 11);
//         write(2, cmd->args[0], ft_strlen(cmd->args[0]));
//         write(2, ": command not found\n", 20);
//         ft_free_split(split_path);
//         exit(127);
//     }
//     else if (child_pid > 0)
//     {
//         waitpid(child_pid, &status, 0);
//         cmd->data.exit_status = WEXITSTATUS(status);
//         printf("%d\n", cmd->data.exit_status);
//         ft_free_split(split_path);
//     }
//     else
//     {
//         perror("fork failed");
//         ft_free_split(split_path);
//     }
// }#include "minishell.h"

// int	is_valid_key(char *key)
// {
// 	int i;

// 	if (!key || (!((key[0] >= 'a' && key[0] <= 'z') || 
// 	               (key[0] >= 'A' && key[0] <= 'Z') || 
// 	               key[0] == '_')))
// 		return (1);

// 	i = 1;
// 	while (key[i] && key[i] != '=')
// 	{
// 		if (!((key[i] >= 'a' && key[i] <= 'z') ||
// 		      (key[i] >= 'A' && key[i] <= 'Z') ||
// 		      (key[i] >= '0' && key[i] <= '9') ||
// 		      key[i] == '_'))
// 			return (1);
// 		i++;
// 	}
// 	return (0);
// }

t_env *sort_env(t_env **head)
{
    t_env *helper = NULL;
    char *tmp_key;
    char *tmp_value;
    helper = *head;
    if(!*head || !head)
        return (NULL);
    while(*head && (*head)->next != NULL)
    {
        if(ft_strcmp((*head)->key, (*head)->next->key) > 0)
        {
            tmp_key = (*head)->key;
            tmp_value = (*head)->value;
            (*head)->key = (*head)->next->key;
            (*head)->value = (*head)->next->value;
            (*head)->next->key = tmp_key;
            (*head)->next->value = tmp_value;
            *head = helper;
        }
        else
            *head = (*head)->next;
    }
    return (helper);
}

char *get_value(char *str)
{
    int i = 0;
    int tmp = 0;
    unsigned int len = 0;
    char *helper = NULL;
    while(str[i] && str[i] != '=' && str[i] != '+')
    i++;
    if(str[i] == '+')
        i++;
    if(str[i] == '=')
        i++;
    tmp = i;
    while(str[i])
    {
        len++;
        i++;
    }
    helper = ft_substr(str, tmp, len);
    if (!helper)
        return (NULL);
    return (helper);
}
char    *get_key(char *str)
{
    unsigned int i = 0;
    while(str[i])
    {
        if(str[i] == '+' && str[i + 1] == '=')
        break ;
        if (str[i] == '=')
        break ;
        i++;
    }
    char *helper = ft_substr(str, 0, i);
    if(!helper)
        return (NULL);
    return (helper);
}

int check_append(char *str)
{
    int i;

    i = 0;
    while (str[i])
    {
        if (str[i] == '+' && str[i + 1] == '=')
        {
            return ('+');
        }
        else if (str[i] == '=')
        {
            return ('=');
        }
        i++;
    }
    return (0);
}

void    set_env(t_env **env, char *key, char *value)
{
    t_env *tmp;
    t_env *new_node = NULL;
    char *old_value;
	tmp = *env;
	while(tmp)
	{
        if(ft_strcmp(tmp->key, key) == 0)
		{
            if (tmp->value)
            {
                old_value = tmp->value;
                tmp->value = ft_strjoin(tmp->value, value);
                free(old_value);
            }
            tmp->is_not_active = 0;
		}
		tmp = tmp->next;
	}
    new_node = malloc(sizeof(t_env));
	if(!new_node)
		return;
	new_node->key = strdup(key);
	new_node->value = strdup(value);
	new_node->is_not_active = 0;
	new_node->next = NULL;
	ft_lstadd_back(env, new_node);
}

int ft_check(t_env *env_list, char *key)
{
    t_env *tmp;
    
    tmp = env_list;
    
    while(tmp)
    {
        if(ft_strcmp(key, tmp->key) == 0)
        {
            return (1);
        }
        tmp = tmp->next;
    }
    return (0);
}
int ft_handel_export(char **str, t_env **lst)
{
    int i = 0;
    char *key = NULL;
    char *value = NULL;
    int status = 0;
    while(str[i])
    {
        key = get_key(str[i]);
        if(is_valid_key(key) == 1)
        {
            printf("minishell: export: %s : not valid identifier\n", str[i]);
            status = 1;
            free(key);
            i++;
            continue;
        }
        value = get_value(str[i]);
        if((ft_strchr(str[i], '=') == NULL))
        {
           if (ft_check(*lst, key) == 1)
           {
                printf("%s\n", str[i]);
                free(key);
                free(value);
                i++;
                continue;
           }
        }
        if(check_append(str[i]) == '+')
        {
            puts("jjjj");
            set_env(lst, key, value);
        }
        if (check_append(str[i]) == '=')
        {
            updat_env(lst, key, value);
        }
        if(check_append(str[i]) == 0)
        {
            value_empty(lst, key);
        }
        free(key);
        free(value);
        i++;
    } 
    return (status);
}
void print_export(t_env *env_list)
{
    t_env *tmp = env_list;
    
    while(tmp)
    {
        if(tmp->value)
        {
            printf("declare -x %s=\"%s\"\n", tmp->key, tmp->value);
        }
        else
            printf("declare -x %s\n", tmp->key);
        tmp = tmp->next;
    }  
}
int ft_export(char **str, t_env **env_list)
{
    int status;
    
    status  = 0;
    *env_list = sort_env(env_list);
    if(!str[1])
    {
        print_export(*env_list);
        return (0);
    }
    else
    {
        status = ft_handel_export(str + 1, env_list);
        return (status);     
    }
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_cd.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anel-men <anel-men@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/14 14:05:15 by ayoakouh          #+#    #+#             */
/*   Updated: 2025/06/05 18:37:59 by anel-men         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

// static void	copy_strings(char *ptr, const char *s1, const char *s2)
// {
// 	unsigned int	i;
// 	unsigned int	j;

// 	i = 0;
// 	while (s1[i] != '\0')
// 	{
// 		ptr[i] = s1[i];
// 		i++;
// 	}
// 	j = 0;
// 	while (s2[j] != '\0')
// 	{
// 		ptr[i + j] = s2[j];
// 		j++;
// 	}
// 	ptr[i + j] = '\0';
// }

// char	*ft_strjoin(char const *s1, char const *s2)
// {
// 	char			*ptr;
// 	size_t			total_len;

// 	if (!s1 && !s2)
// 		return (NULL);
// 	if (!s1)
// 		return (strdup(s2));
// 	if (!s2)
// 		return (strdup(s1));
// 	total_len = strlen(s1) + strlen(s2);
// 	ptr = (char *)malloc (sizeof(char) * (total_len + 1));
// 	if (ptr == NULL)
// 		return (NULL);
// 	copy_strings(ptr, s1, s2);
// 	return (ptr);
// }

char *get_value_env(char *key, t_env **list)
{
	t_env   *tmp;


	  if (!list || !*list || !key)
        return (NULL);

		
	tmp = *list;
	while(tmp != NULL && tmp->key != NULL)
	{
		if(ft_strcmp(tmp->key, key) == 0)
		{
			return (tmp->value);
		}
		tmp = tmp->next;
	}
	return (NULL);
}
void    set_value_env(t_env **env, char *key, char *value)
{
	t_env *tmp;

	tmp = *env;
	while(tmp)
	{
		if(ft_strcmp(tmp->key, key) == 0)
		{
			if (tmp->value)
			{
				free(tmp->value);
				tmp->value = NULL;
			}
			tmp->value = ft_strjoin(tmp->value, value);
			return ;
		}
		tmp = tmp->next;
	}
}

void updat_env(t_env **env_list, char *key, char *value)
{
	t_env *tmp;
	t_env *new_node;

	tmp = *env_list;
	while(tmp)
	{
		if (strcmp(key, tmp->key) == 0)
		{
			free(tmp->value);
			tmp->value = strdup(value);
			tmp->is_not_active = 0;
			return;
		}
		tmp = tmp->next;
	}
	new_node = malloc(sizeof(t_env));
	if(!new_node)
		return;
	new_node->key = strdup(key);
	new_node->value = strdup(value);
	new_node->is_not_active = 0;
	new_node->next = NULL;
	ft_lstadd_back(env_list, new_node);
}

char *get_path(char *str, t_env **list)
{
	char *path;

	path = NULL;
	if(str == NULL || str[0] == '~')
	{
		path = get_value_env(strdup("HOME"), list);
		if(!path)
			return(NULL);
	}
	else if(!path)
	{
		path = str;
	}
	return (path);
}
char *check_pwd(t_env **list, char *str, char *old_pwd)
{
	static char *new_pwd;
	char *tmp;

    write(2, "minishell: cd: error retrieving current directory\n", 50);
	if (old_pwd[ft_strlen(old_pwd) - 1] != '/')
	{
		tmp = ft_strjoin(old_pwd, "/");
		printf("%s\n", tmp);
		if(!tmp)
			return (NULL);
		new_pwd = ft_strjoin(tmp, str);
		free(tmp);
	}
	else
	{
		new_pwd = ft_strjoin(old_pwd, str);
		if(!new_pwd)
			return (NULL);
	}
	updat_env(list, "PWD", new_pwd);
	return (new_pwd);
}
int ft_cd(char **str, t_env **list, t_data data)
{
    char *cwd;
    char *new_cwd;
    char *value;
	char *new_pwd;

    new_cwd = get_path(str[1], list);
    value = get_value_env("PWD", list);
    if (!new_cwd || chdir(new_cwd) == -1)
    {
		// ft_putstr_fd("minishell: ", 2);
		strerror(errno);
		return(1);
    }
    if (value)
        updat_env(list, "OLDPWD", value);

    cwd = getcwd(NULL, 0);
    if (!cwd)
	{
		new_pwd = check_pwd(list, str[1], value);
		data.new_pwd = new_pwd;
	}
    else
    {
        set_value_env(list, "PWD", cwd);
        free(cwd);
    }
    return (0);
}

// int	ft_cd(char **str, t_env **list)
// {
// 	char	*cwd;
// 	char	*new_cwd;
// 	char	*value;
// 	static new_pwd;

// 	new_cwd = get_path(str[1], list);
// 	value = get_value_env("PWD", list); // detsktop//cccc/0/1/2;
// 	if(!new_cwd || chdir(new_cwd) == -1)
// 	{
// 		write(2, "minishell: cd: HOME not set\n", 28);
// 		return (1);
// 	}
// 	if(value)
// 		updat_env(list, "OLDPWD", value);
// 	// set_value_env(list, "OLDPWD", value);
// 	cwd = getcwd(NULL, 0);
// 	if(!cwd)
// 	{
// 		check_pwd(new_pwd, cwd, value);
// 	}
// 	set_value_env(list, "PWD", cwd);
// 	free(cwd);
// 	return (0);
// }/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_exit.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anel-men <anel-men@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/15 18:26:45 by ayoakouh          #+#    #+#             */
/*   Updated: 2025/06/04 12:27:35 by anel-men         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int    ft_space(const char **str, int sign)
{
    while ((**str >= 9 && **str <= 13) || **str == 32)
        (*str)++;
    if (**str == '-' || **str == '+')
    {
        if (**str == '-')
            sign *= -1;
        (*str)++;
    }
    return (sign);
}

long    ft_atoi(const char *str)
{
    int                i;
    int                sign;
    long            res;
    long            tmp;

    sign = 1;
    i = 0;
    res = 0;
    tmp = 0;
    sign = ft_space(&str, sign);
    while (str[i] >= '0' && str[i] <= '9')
    {
        res = res * 10 + (str[i] - 48);
        if (res / 10 != tmp)
            return (LONG_MAX);
        tmp = res;
        i++;
    }
    return (res * sign);
}

void	 ft_putendl_fd(char	*s, int fd)
{
	unsigned int	i;

	i = 0;
	if (!s)
		return ;
	if (fd >= 0)
	{
		while (s[i])
		{
			write(fd, &s[i], 1);
			i++;
		}
		write(fd, "\n", 1);
	}
}
int	ft_isdigit(int c)
{
	if (c >= '0' && c <= '9')
		return (1);
	else
		return (0);
}
// size_t ft_strlen(char *str)
// {
//     int i = 0;
//     while(str[i])
//         i++;
//     return (i);
// }

int is_numeric(char *str)
{
    int i = 0;
    if (str[i] == '-' || str[i] == '+')
        i++;
    while (str[i])
    {
        if (!ft_isdigit(str[i]))
            return (0);
        i++;
    }
    return (1);
}

int ft_exit(char **args, t_data data)
{
    long    n;
    
    // status = 0;
    ft_putendl_fd("exit", 2);
    
    if (!args || !args[1])
    {
        data.exit_status = get_or_set(SET, 0);
        exit(0);
    }
    if (!is_numeric(args[1]))
    {
        ft_putendl_fd("exit: numeric argument required", 2);
        data.exit_status = get_or_set(SET, 255);
        exit(255);
    }
    if (args[2])
    {
        ft_putendl_fd("minishell: too many arguments", 2);
        data.exit_status = get_or_set(SET, 1);
        return 0;
    }
    n = ft_atoi(args[1]);
    if ((n == LONG_MAX && ft_strcmp(args[1], "9223372036854775807") != 0) || (n == LONG_MAX && ft_strcmp(args[1], "-9223372036854775808") != 0))
    {
        ft_putendl_fd("exit: numeric argument required...", 2);
        data.exit_status = get_or_set(SET, 255);
        exit(255);
    }
    if(n < 0)
        n = n % 256 + 256;
    else 
        n = n % 256;
    data.exit_status = get_or_set(SET, (int)n);
    return(data.exit_status);
    exit(data.exit_status);
}




















// void    ft_exit(char **args)
// {
//     long n ;
//     if(!args || !args[1])
//         exit(0);
//     if(!is_numeric(args[1]))
//     {
//         write(2, "exit: ", 6);
//         write(2, &args[1], ft_strlen(args[1]));
//         write(2, ": numeric argument required", 27);
//         exit(2);
//     }
//     if(args[2])
//     {
//         write(2, "exit", 4);
//        write(2, " exit: too many argument\n", 24); 
//        return ;
//     }
//     n = ft_atoi(args[1]);
//     if(ft_strcmp(args[1], "9223372036854775807") != 0 && n == LONG_MAX)
//     {
//         exit(255);
//     }
    
    
    
//     printf("exit\n");

// }
// void minishell_exit(char **args, t_env *shell)
// {
//     // if (!is_child_process)
//     //     ft_putendl_fd("exit", 1);
 
//     if (!args[1])
//     {
//         // free_all(shell);
//         exit(shell->last_exit_status);
//     }

//     if (!is_numeric(args[1]))
//     {
//         ft_putstr_fd("minishell: exit: ", 2);
//         ft_putstr_fd(args[1], 2);
//         ft_putendl_fd(": numeric argument required", 2);
//         // free_all(shell);
//         exit(255);
//     }

//     if (args[2])
//     {
//         ft_putendl_fd("minishell: exit: too many arguments", 2);
//         shell->last_exit_status = 1;
//         return;
//     }
//     long exit_status = atoi(args[1]);
//     // free_all(shell);
//     exit((unsigned char)exit_status);
// }

// void ft_exit(t_env **env_list, char **str)
// {

// }/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_split.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anel-men <anel-men@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/08 12:00:49 by ayoakouh          #+#    #+#             */
/*   Updated: 2025/05/29 17:13:04 by anel-men         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static	int	ft_count_strings(char const *s, char c)
{
	int	i;
	int	count;

	i = 0;
	count = 0;
	while (s[i] != '\0')
	{
		while (s[i] != '\0' && s[i] == c)
			i++;
		if (s[i] != '\0')
		{
			count++;
		}
		while (s[i] != '\0' && s[i] != c)
		{
			i++;
		}
	}
	return (count);
}

static int	ft_lent_strlen(char const *s, char c)
{
	int	i;

	i = 0;
	while (s[i] != '\0' && s[i] != c)
		i++;
	return (i);
}

static char	*ft_word(char const *s, char c)
{
	int		len_word;
	int		i;
	char	*word;

	i = 0;
	len_word = ft_lent_strlen(s, c);
	word = (char *)malloc(len_word + 1);
	if (word == NULL)
	{
		return (NULL);
	}
	while (i < len_word)
	{
		word[i] = s[i];
		i++;
	}
	word[i] = '\0';
	return (word);
}

static int	ft_fill_string(char **str, char const *s, char c)
{
	int	i;
	int	j;

	i = 0;
	j = 0;
	while (s[i] != '\0')
	{
		while (s[i] != '\0' && s[i] == c)
			i++;
		if (s[i] != '\0')
		{
			str[j] = ft_word(&s[i], c);
			if (str[j] == NULL)
				return (0);
			j++;
		}
		while (s[i] != '\0' && s[i] != c)
			i++;
	}
	str[j] = 0;
	return (1);
}

char	**ft_split(char const *s, char c)
{
	char	**strings;
	int		i;

	i = 0;
	if (s == NULL)
		return (NULL);
	strings = (char **)malloc(sizeof(char *) * (ft_count_strings(s, c) + 1));
	if (strings == NULL)
	{
		return (NULL);
	}
	if (ft_fill_string(strings, s, c) == 0)
	{
		while (strings[i] != NULL)
		{
			free(strings[i]);
			i++;
		}
		free(strings);
		return (NULL);
	}
	return (strings);
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_unset.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anel-men <anel-men@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/15 14:33:17 by ayoakouh          #+#    #+#             */
/*   Updated: 2025/06/05 22:47:31 by anel-men         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */






#include "minishell.h"


// void del(void *content)
// {
//     free(content);
// }

// int remove_env(t_env **env_list, char *variable)
// {
//     t_env *tmp;
//     t_env *to_delete;

//     if (!*env_list || !env_list)
//         return (0);
//     if (ft_strcmp((*env_list)->key, variable) == 0)
//     {
//         puts("HHH\n");
//         to_delete = *env_list;
//         *env_list = (*env_list)->next;
//         // del(to_delete->key);
//         del(to_delete->value);
//         // free(to_delete);
//         return (1);
//     }
    
//     // Check rest of list
//     tmp = *env_list;
//     while (tmp->next)
//     {
//         if (ft_strcmp(tmp->next->key, variable) == 0)
//         {
//             to_delete = tmp->next;
//             tmp->next = tmp->next->next;
//             del(to_delete->key);
//             del(to_delete->value);
//             free(to_delete);
//             return (1);
//         }
//         tmp = tmp->next;
//     }
    
//     return (0); // Variable not found
// }

void del(void *content)
{
    free(content);
}

int remove_env(t_env **env_list, char *variable)
{
    t_env *tmp;
    t_env *to_delete;

    if (!*env_list || !env_list)
        return (0);
    if (ft_strcmp((*env_list)->key, variable) == 0)
    {
        to_delete = *env_list;
        *env_list = (*env_list)->next;
        // Fix: Free both key and value, and the node itself
        del(to_delete->key);
        if (to_delete->value)
            del(to_delete->value);
        free(to_delete);
        return (1);
    }
    
    // Check rest of list
    tmp = *env_list;
    while (tmp->next)
    {
        if (ft_strcmp(tmp->next->key, variable) == 0)
        {
            to_delete = tmp->next;
            tmp->next = tmp->next->next;
            del(to_delete->key);
            if (to_delete->value)
                del(to_delete->value);
            free(to_delete);
            return (1);
        }
        tmp = tmp->next;
    }
    
    return (0); // Variable not found
}

int ft_unset(t_env **env_list, char **variables)
{
    int i;
    int status;
    
    i = 0;
    status = 0;
    if (!variables)
        return 0;
    while (variables[i])
    {
        if(is_valid_key(variables[i]))
        {
            printf("unset: `%s': not a valid identifier\n", variables[i]);
            status = 1;
            i++;
            continue;
        }
        remove_env(env_list, variables[i]);
        i++;
    }
    return (status);
}
// #include "minishell.h"

// int    ft_strcmp(char *s1, char *s2)
// {
//     int i = 0;
//     while(s1[i] || s2[i])
//     {
//         if(s1[i] > s2[i])
//             return(1);
//         if(s1[i] < s2[i])
//             return (-1);
//             i++;
//     }
//     return(0);
// }
// void del(void *content)
// {
//     free(content);
// }
// char *remove_env(t_env **env_list, char *variable)
// {
//     t_env   *tmp;

//     if(!*env_list)
//         return ;
//     tmp = *env_list;
//     while(tmp)
//     {
//         if(ft_strcmp(tmp->next->key, variable) == 0)
// 		{
            
// 			del(tmp->key);
// 			del(tmp->value);
//             free(tmp);
//             return ()
// 		}
//         tmp = tmp->next;
//     }
// }

// void ft_unset(t_env **env_list, char *variable)
// {
//     t_env *temp;

//     remove_env(env_list, variable);    

// }// /* ************************************************************************** */
// /*                                                                            */
// /*                                                        :::      ::::::::   */
// /*   main.c                                             :+:      :+:    :+:   */
// /*                                                    +:+ +:+         +:+     */
// /*   By: ayoakouh <ayoakouh@student.42.fr>          +#+  +:+       +#+        */
// /*                                                +#+#+#+#+#+   +#+           */
// /*   Created: 2025/04/25 20:41:00 by ayoakouh          #+#    #+#             */
// /*   Updated: 2025/05/07 14:26:07 by ayoakouh         ###   ########.fr       */
// /*                                                                            */
// /* ************************************************************************** */




// // Create pipes for all commands that need them
// void pipe_all(t_cmd *head)
// {
//     t_cmd *cmd = head;

//     while (cmd)
//     {
//         if (cmd->pipe_out)
//         {
//             if (pipe(cmd->fd_pipe) < 0) // Check for pipe creation errors
//             {
//                 perror("pipe error");
//                 exit(EXIT_FAILURE);
//             }
//         }
//         cmd = cmd->next;
//     }
// }

// int list_size(t_cmd *begin_list)
// {
//     int size = 0;
    
//     while (begin_list)
//     {
//         begin_list = begin_list->next;
//         size += 1;
//     }
//     return (size);
// }

// // Close all pipes to prevent leaks
// void close_all_pipes(t_cmd *cmd)
// {
//     t_cmd *tmp = cmd;
    
//     while (tmp)
//     {
//         if (tmp->pipe_out)
//         {
//             close(tmp->fd_pipe[0]);
//             close(tmp->fd_pipe[1]);
//         }
//         tmp = tmp->next;
//     }
// }

// void ft_excute_mult_pipe(t_cmd *cmd, t_env *list_env, char *env[])
// {
//     pid_t pid1;
//     t_cmd *prev = NULL;
//     t_cmd *head = cmd;
//     int fd_input, fd_output;
    
//     // Save original stdin/stdout
//     fd_input = dup(STDIN_FILENO);
//     fd_output = dup(STDOUT_FILENO);
    
//     if (fd_input < 0 || fd_output < 0)
//     {
//         perror("dup error");
//         return;
//     }
    
//     cmd->total_pipes = list_size(cmd) - 1;
//     pipe_all(cmd);
    
//     while (cmd)
//     {
//         pid1 = fork();
//         if (pid1 < 0)
//         {
//             perror("fork error");
//             close_all_pipes(head);
//             close(fd_input);
//             close(fd_output);
//             return;
//         }
//         else if (pid1 == 0)  // Child process
//         {
//             // Close all pipes not needed by this process
//             t_cmd *tmp = head;
//             while (tmp)
//             {
//                 // Close pipes that this command doesn't need
//                 if (tmp != cmd && tmp != prev)
//                 {
//                     if (tmp->pipe_out)
//                     {
//                         close(tmp->fd_pipe[0]);
//                         close(tmp->fd_pipe[1]);
//                     }
//                 }
//                 tmp = tmp->next;
//             }
            
//             // Handle redirections first - they take precedence
//             if (cmd->redirs != NULL)
//             {
//                 // Close any pipes that would be overridden by redirections
//                 if (prev && prev->pipe_out)
//                 {
//                     close(prev->fd_pipe[0]);
//                     close(prev->fd_pipe[1]);
//                 }
//                 if (cmd->pipe_out)
//                 {
//                     close(cmd->fd_pipe[0]);
//                     close(cmd->fd_pipe[1]);
//                 }
                
//                 ft_redircte(cmd->redirs);
//             }
//             else 
//             {
//                 // Setup input from previous pipe if needed
//                 if (prev != NULL && prev->pipe_out)
//                 {
//                     dup2(prev->fd_pipe[0], STDIN_FILENO);
//                     close(prev->fd_pipe[0]);
//                     close(prev->fd_pipe[1]);
//                 }
                
//                 // Setup output to next pipe if needed
//                 if (cmd->pipe_out)
//                 {
//                     dup2(cmd->fd_pipe[1], STDOUT_FILENO);
//                     close(cmd->fd_pipe[0]);
//                     close(cmd->fd_pipe[1]);
//                 }
//             }
            
//             ft_excute_commands(cmd, &list_env);
//             exit(127);
//         }
        
//         // Parent process: close pipes we don't need anymore
//         if (prev && prev->pipe_out)
//         {
//             close(prev->fd_pipe[0]);
//             close(prev->fd_pipe[1]);
//         }
        
//         prev = cmd;
//         cmd = cmd->next;
//     }
    
//     // Close any remaining pipes in parent
//     if (prev && prev->pipe_out)
//     {
//         close(prev->fd_pipe[0]);
//         close(prev->fd_pipe[1]);
//     }
    
//     // Wait for all child processes to finish
//     while (wait(NULL) > 0)
//         ;
    
//     // Restore original stdin/stdout
//     dup2(fd_input, STDIN_FILENO);
//     dup2(fd_output, STDOUT_FILENO);
//     close(fd_input);
//     close(fd_output);
// }
// // #include "minishell.h"

// // // int ft_check_rederction(t_redir *cmd)
// // // {
// // //     t_redir *tmp;

// // //     tmp = cmd;
// // //     // while(tmp)
// // //     // {
// // //         if(tmp->redirs != NULL)
// // //         {
// // //             ft_redircte(&cmd);
// // //             return (0);
// // //         }
// // //         // tmp = tmp->next;
// // //     // }
// // //     return (1);
// // // }
// // int is_builtin(char **args)
// // {
// // 	if (strcmp(args[0], "cd") == 0)
// // 		return (0);
// // 	else if (strcmp(args[0], "echo") == 0)
// // 		return (0);
// // 	else if (strcmp(args[0], "unset") == 0)
// // 		return (0);
// // 	else if (strcmp(args[0], "export") == 0)
// // 		return (0);
// // 		else if (strcmp(args[0], "pwd") == 0)
// // 			return (0);
// // 		else if (strcmp(args[0], "env") == 0)
// // 			return (0);
// // 		else if (strcmp(args[0], "exit") == 0)
// // 			return (0);
// // 		else
// // 			return (1);
// // }
// // // void minishell_cmd(char *env[])
// // // {
// // // 	pid_t pid = fork();
// // // 		if (pid == 0)
// // // 		{
// // // 			char *args[] = {"./minishell", NULL};
// // // 			execve("./minishell", args, env);
// // // 		}
// // // 		else
// // // 		{
// // // 			waitpid(pid, NULL, 0);
// // // 		}
// // // }
// // int get_or_set(int type, int status)
// // {
// // 	static int exit_status = 0; // hold the value even after function ends

// // 	if (type == SET) //SET
// // 		exit_status = status; // rje3 dkre hadik kifch dkhlha m3a exit_status;
// // 	return (exit_status); // always return the current value
// // }

// // void excute_builting(t_cmd **command, t_env *env_list, char *env[])
// // {
// // 	t_cmd	*cmd;
// // 	int		status;
// // 	t_env  *help;

// // 	cmd = *command;
// // 	status = 0;

// // 	if (strncmp("export", cmd->args[0], 6) == 0 && strlen(cmd->args[0]) == 6)
// // 		status = ft_export(cmd->args, &env_list);
// // 	else if (strncmp("env", cmd->args[0], 3) == 0 && strlen(cmd->args[0]) == 3)
// // 		status = ft_env(*command, env_list);
// // 	else if (strncmp("exit", cmd->args[0], 4) == 0 && strlen(cmd->args[0]) == 4)
// // 	{
// // 		ft_exit(cmd->args, cmd->data);
// // 		free_cmd_list(cmd);
// // 	}
// // 	else if (strncmp("unset", cmd->args[0], 5) == 0 && strlen(cmd->args[0]) == 5)
// // 	{ 
// // 		status = ft_unset(&env_list, cmd->args + 1);
// // 	}
// // 	else if (strncmp("echo", cmd->args[0], 4) == 0 && strlen(cmd->args[0]) == 4)
// // 		status = echo(cmd->args);
// // 	else if (strncmp("pwd", cmd->args[0], 3) == 0 && strlen(cmd->args[0]) == 3)
// // 		status = pwd();
// // 	else if (strncmp("cd", cmd->args[0], 2) == 0 && strlen(cmd->args[0]) == 2)
// // 		status = ft_cd(cmd->args, &env_list);
// // 	cmd->data.exit_status = get_or_set(SET, status);
// // 	printf("%d\n", cmd->data.exit_status);
// // }
// // void excute_siingle(t_cmd *cmd, t_env *list_env, char *env)
// // {
// // 	if(cmd->redirs != NULL)
// // 	{
// // 		ft_redircte(cmd->redirs);
// // 	}
// // 	if(!is_builtin(cmd->args))
// // 	{
// // 		dprintf(2, "hllo\n");
// // 		excute_builting(&cmd, list_env, env);
// // 	}
// // 	else
// // 	{
// // 		ft_excute_commands(cmd, &list_env);
// // 		printf(".....%d\n", cmd->data.exit_status);
// // 	}
// // }

// // void check_line(t_cmd **command, t_env *env, char *en[])
// // {
// // 	 t_cmd *cmd;
// // 	  cmd = *command;
// // 	  int fd_input ;
// // 	  int fd_output ;
// // 		fd_input = dup(0);
// // 		fd_output = dup(1);
// // 		if (cmd->pipe_out == 1)
// // 		{
// // 			ft_excute_mult_pipe(cmd, env, en);
// // 			return ;
// // 		}
// // 	else
// // 	{
// // 	//   while(cmd)
// // 	//   {
// // 			if(cmd->redirs != NULL)
// // 			{
// // 				ft_redircte(cmd->redirs);
// // 			}
// // 			if(!is_builtin(cmd->args))
// // 			{
// // 				excute_builting(&cmd, env, en);
// // 			}
// // 			else
// // 			{
// // 				ft_excute_commands(cmd, &env);
// // 				printf(".....%d\n", cmd->data.exit_status);
// // 			}
// // 			// cmd = cmd->next;
// // 		// }
// // 	}
// // 	dup2(fd_input, 0);
// // 	dup2(fd_output, 1);
// // 	close(fd_input);
// // 	close(fd_output);
// // }
// // // void ff()
// // // {
// // // 	system("lsof minishell");
// // // }
// // int main(int argc, char *argv[], char *env[])
// // {
// // 	// atexit(ff);
// // 	t_token *token_list;
// // 	t_env *env_struct = NULL;   //// add to the final main
// // 	int exit_status = 0;
// // 	char *input;
// // 	t_cmd *cmd;
	
// // 	(void)argc;
// // 	(void)argv;

// // 	env_struct = env_maker(env, &env_struct);
// // 	token_list = NULL;
// // 	while (1)
// // 	{
// // 		input = readline("minishell $> ");
// // 		// cmd = NULL;
// // 		if (!input)
// // 			break;
// // 		add_history(input);
// // 		if (check_quotes(input))
// // 		{
// // 			// Error message already printed by check_quotes
// // 			free(input);
// // 			continue;
// // 		}
// // 		token_list = tokin_list_maker(input);
// // 		if (token_list && !error_pipi(token_list)  && !check_syntax_errors(token_list))
// // 		{
// // 			// printf("--- TOKENS ---\n");
// // 			expand_handle(token_list, env_struct, exit_status);
// // 			//process_quotes_for_tokens(token_list, 1);
// // 			cmd = parser(token_list);
// // 			// ft_excute(cmd);
// // 			check_line(&cmd, env_struct, env);
// // 			//debug_print_cmd(cmd);
// // 			if (cmd == NULL) {
// // 				printf("Warning: Command list is empty after parsing!\n");
// // 			} else {
// // 				// process_quotes_for_cmd(cmd, 1);
// // 				// print_cmd(cmd);
// // 				// if (cmd)
// // 				// 	free_cmd_list(cmd);
// // 			}
// // 		}   
// // 		free_token_list(token_list);
// // 		free(input);
// // 	}
// // 	free_env_struct(env_struct);
// // 	return 0;
// // }/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   libft_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ayoakouh <ayoakouh@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/11/12 19:10:36 by ayoakouh          #+#    #+#             */
/*   Updated: 2025/05/28 17:11:32 by ayoakouh         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
// void ft_free(t_env **list)
// {
// 	t_env *tmp;

// 	tmp = *list;
// 	t_env *tmp2;
// 	while(tmp)
// 	{
// 		free(tmp->key);
// 		free(tmp->value);
// 		tmp2 = tmp;
// 		free(tmp);
// 		tmp = tmp2;
// 		tmp = tmp->next;
// 	}
// }
int		ft_list_size(t_env *begin_list)
{
	int		size;
	
    size = 0;
    while (begin_list)
    {
        begin_list = begin_list->next;
        size += 1;
    }
	return (size);
}
char	*ft_strchr(char *s, int c)
{
	int		i;
	char	m;

	i = 0;
	m = c;
	while (s[i] != '\0')
	{
		if (s[i] == m)
			return ((char *)&s[i]);
		i++;
	}
	if (m == '\0')
		return ((char *)&s[i]);
	return (NULL);
	
}

int ft_strcmp(char *s1, char *s2)
{
    int i = 0;
    while(s1[i] || s2[i])
    {
        if(s1[i] > s2[i])
            return(1);
        if(s1[i] < s2[i])
            return(-1);
        i++;
    }
    return(0);
}

t_env	*ft_lstnew(void *content)
{
	t_env	*nw_node;

	nw_node = (t_env *)malloc(sizeof(t_env));
	if (nw_node == NULL)
		return (NULL);
	nw_node->value = content;
	nw_node->next = NULL;
	return (nw_node);
}

void	ft_lstadd_back(t_env **lst, t_env *new)
{
	t_env	*current;

	if (!new)
		return ;
	if (*lst == NULL)
	{
		*lst = new;
		return ;
	}
	current = *lst;
	while (current ->next != NULL)
	{
		current = current->next;
	}
	current ->next = new;
}

// char	*ft_substr(char const *s, unsigned int start, size_t len)
// {
// 	char	*ptr;
// 	size_t	i;
// 	size_t	l;

// 	i = 0;
// 	if (s == NULL)
// 		return (NULL);
// 	l = strlen(s);
// 	if (start >= l)
// 		return (strdup(""));
// 	if (len > l - start)
// 		len = l - start;
// 	ptr = (char *)malloc(sizeof(char) * len + 1);
// 	if (ptr == NULL)
// 		return (NULL);
// 	while (i < len)
// 	{
// 		ptr[i] = s[start + i];
// 		i++;
// 	}
// 	ptr[len] = '\0';
// 	return (ptr);
// }/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lll.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anel-men <anel-men@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/15 15:22:58 by ayoakouh          #+#    #+#             */
/*   Updated: 2025/05/31 18:02:50 by anel-men         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"


void ft(char **args, t_env **list) // pipe moust be check and access;;;;*
{
    char **split_path;
    char **helper;
    char *path;
    int i= 0;
    char *tmp;

    helper = convert_env_list(list);
    path = check_path(list);
    if(!args || !args[0])
        return ;
    if(ft_strchr(args[0], '/'))
    {
        if(!(access(args[0], X_OK) == -1))
        {
            execve(args[0], args, helper);
            exit (1); //ila failat execve
        }
        write(1, "command not found\n", 18);
    }
    else
    {
        split_path = ft_split(path, ':');
        if(!split_path)
            return ;
        while(split_path[i])
        {
            tmp = ft_strjoin(split_path[i], "/");
            char *str = ft_strjoin(tmp, args[0]);
            free(tmp);
            if (!helper)
            {
                i++;
                continue;
            }
            if(!(access(str, X_OK) == -1))
            {
                execve(str, args, helper);
                exit (1);
            }
            free(str);
            i++;
        }
        i = 0;
        write(2, "command not found\n", 18);
        ft_free_split(split_path);
        exit(127);
    }        
}
void    pipe_all(t_cmd *head)
{
    t_cmd *cmd = head;

    while (cmd)
    {
        
        if (cmd->pipe_out)
        {
            pipe(cmd->fd_pipe); // creates cmd->fd_pipe[0] (read) and [1] (write)
        }
        cmd = cmd->next;
    }
}
char **convert_env_list(t_env **list)
{
    t_env * tmp;
    char **helper = NULL;
    char *str;
    char *temp;
    int  i = 0;
    tmp = *list;
    int len = ft_list_size(*list);

    helper = malloc(sizeof(char *) * (len + 1));
    while(tmp)
    {
        str = ft_strdup(tmp->key);
        temp = ft_strjoin(str, "=");
        free(str);
        str = ft_strjoin(temp, tmp->value);
        free(temp);
        helper[i] = ft_strdup(str);
        free(str);
        tmp = tmp->next;
        i++;
    }
    helper[i] = NULL;
    return (helper);
}
void close_all_pipes(t_cmd *cmd)
{
    t_cmd *tmp = cmd;
    
    while (tmp)
    {
        if (tmp->pipe_out)
        {
            close(tmp->fd_pipe[0]);
            close(tmp->fd_pipe[1]);
        }
        tmp = tmp->next;
    }
}

void check_close_red(t_cmd *cmd, t_cmd *prev, t_env *env)
{
//         if (prev && prev->pipe_out)
//         {
//             close(prev->fd_pipe[0]);
//             close(prev->fd_pipe[1]);
//         }
//         if (cmd->pipe_out)
//         {
//             close(cmd->fd_pipe[0]);
//             close(cmd->fd_pipe[1]);
//         }
        // if (!isatty(cmd->redirs->fd)) //check if this function is working;
            ft_redircte(cmd->redirs, env, cmd);
}

void handl_si(int sig)
{
    ft_putstr_fd("Quit: 3\n", 1);
    // cmd->data.exit_status = get_or_set(SET, 131);
    rl_redisplay();
}

void ft_free_redrect(t_redir *redir)
{
    t_redir *tmp = redir;
    if(!tmp)
        return ;
    while (tmp && tmp->fd)
    {
        close(tmp->fd);
        tmp = tmp->next;
    }

}
void ft_excute_mult_pipe(t_cmd *cmd, t_env *list_env, char *env[])
{
    pid_t pid;
    t_cmd *prev = NULL;
    t_cmd *head = NULL;
    int last_pid = 0;
    int status = 0;
    int last_status = 0;

    head = cmd;

    signal(SIGINT, SIG_IGN);
    signal(SIGQUIT, SIG_IGN);

    pipe_all(cmd);
     
    while (cmd)
    {
        pid = fork();
        if (pid < 0)
        {
            perror("fork");
            close_all_pipes(head);
            return;
        }
        else if (pid == 0)
        {
            signal(SIGINT, SIG_DFL);
            signal(SIGQUIT, handl_si);
            if (prev && prev->pipe_out)
            {
                dup2(prev->fd_pipe[0], 0);
            }
            if (cmd->pipe_out)
                dup2(cmd->fd_pipe[1], 1);
            if(cmd->redirs != NULL)
            {
                puts("jjjj");
                check_close_red(cmd, prev, list_env);
            }
            // close_all_pipes(head);
            if(cmd->redirs == NULL || cmd->redirs->fd != -1)
                execute_single_command(cmd, list_env, env);
            last_status = cmd->data.exit_status;
            exit(cmd->data.exit_status);
        }
        if(cmd->redirs != NULL)
            ft_free_redrect(cmd->redirs);
        if(cmd->next == NULL)
            last_pid = pid;

        // Parent closes previous pipe ends
        if (prev && prev->pipe_out)
        {
            close(prev->fd_pipe[0]);
            close(prev->fd_pipe[1]);
        }
        prev = cmd;
        cmd = cmd->next;
    }
    close_all_pipes(head);
    	while ((pid = wait(&status)) > 0)
	{
		if (pid == last_pid)
		{
			if (WIFEXITED(status))
				last_status = WEXITSTATUS(status);
			else if (WIFSIGNALED(status))
			{
				int sig = WTERMSIG(status);
				if (sig == SIGQUIT)
					ft_putstr_fd("Quit: 3\n", 1);
				else if (sig == SIGINT)
					ft_putstr_fd("\n", 1);
				last_status = 128 + sig;
			}
            head->data.exit_status = get_or_set(SET, last_status);
		}
	}
    // while (wait(&status) > 0)
    // {
    //     if (WIFEXITED(status))
    //         last_status = WEXITSTATUS(status);
    //     else if (WIFSIGNALED(status))
    //     {
    //         int sig = WTERMSIG(status);
    //         last_status = 128 + sig;
    //     }
    // }
    // Set the exit status to the last command's status
    // close_all_pipes(head);
    // pid_t wpid;
    // while ((pid = waitpid(pid, &status, 0)) > 0)
    // {
    //     if (WIFEXITED(status))
    //     {
    //         last_status = WEXITSTATUS(status);
    //     }
    // }
    get_or_set(SET, last_status);
    
    // // Set the exit status to the last command's status
    // get_or_set(SET, last_status);

    // while (wait(NULL) > 0)
    //     ;
}


// void ft(char **args, t_env **list) // pipe moust be check and access;;;;*
// {
//     char **split_path;
//     char **helper;
//     char *path;
//     int i= 0;
//     char *tmp;

//     helper = convert_env_list(list);
//     path = check_path(list);
//     if(!args || !args[0])
//         return ;
//     if(ft_strchr(args[0], '/'))
//     {
//         if(!(access(args[0], X_OK) == -1))
//         {
//             execve(args[0], args, helper);
//             exit (1); //ila failat execve
//         }
//         write(1, "command not found\n", 18);
//     }
//     else
//     {
//         split_path = ft_split(path, ':');
//         if(!split_path)
//             return ;
//         while(split_path[i])
//         {
//             tmp = ft_strjoin(split_path[i], "/");
//             char *str = ft_strjoin(tmp, args[0]);
//             free(tmp);
//             if (!helper)
//             {
//                 i++;
//                 continue;
//             }
//             if(!(access(str, X_OK) == -1))
//             {
//                 execve(str, args, helper);
//                 exit (1);
//             }
//             free(str);
//             i++;
//         }
//         i = 0;
//         write(2, "command not found\n", 18);
//         ft_free_split(split_path);
//         exit(127);
//     }        
// }
// void    pipe_all(t_cmd *head)
// {
//     t_cmd *cmd = head;

//     while (cmd)
//     {
        
//         if (cmd->pipe_out)
//         {
//             pipe(cmd->fd_pipe); // creates cmd->fd_pipe[0] (read) and [1] (write)
//         }
//         cmd = cmd->next;
//     }
// }
// char **convert_env_list(t_env **list)
// {
//     t_env * tmp;
//     char **helper = NULL;
//     char *str;
//     char *temp;
//     int  i = 0;
//     tmp = *list;
//     int len = ft_list_size(*list);

//     helper = malloc(sizeof(char *) * (len + 1));
//     while(tmp)
//     {
//         str = ft_strdup(tmp->key);
//         temp = ft_strjoin(str, "=");
//         free(str);
//         str = ft_strjoin(temp, tmp->value);
//         free(temp);
//         helper[i] = ft_strdup(str);
//         free(str);
//         tmp = tmp->next;
//         i++;
//     }
//     helper[i] = NULL;
//     return (helper);
// }
// void close_all_pipes(t_cmd *cmd)
// {
//     t_cmd *tmp = cmd;
    
//     while (tmp)
//     {
//         if (tmp->pipe_out)
//         {
//             close(tmp->fd_pipe[0]);
//             close(tmp->fd_pipe[1]);
//         }
//         tmp = tmp->next;
//     }
// }

// void check_close_red(t_cmd *cmd, t_cmd *prev, t_env *env)
// {
//         if (prev && prev->pipe_out)
//         {
//             close(prev->fd_pipe[0]);
//             close(prev->fd_pipe[1]);
//         }
//         if (cmd->pipe_out)
//         {
//             close(cmd->fd_pipe[0]);
//             close(cmd->fd_pipe[1]);
//         }
//         if (!isatty(cmd->redirs->fd)) //check if this function is working;
//             ft_redircte(cmd->redirs, env, cmd);
// }

// void handl_si(int sig)
// {
//     ft_putstr_fd("Quit: 3\n", 1);
//     // cmd->data.exit_status = get_or_set(SET, 131);
//     rl_redisplay();
// }
// void ft_excute_mult_pipe(t_cmd *cmd, t_env *list_env, char *env[])
// {
//     pid_t pid;
//     t_cmd *prev = NULL;
//     t_cmd *head = NULL;
//     int last_pid = 0;
//     int status = 0;
//     int last_status = 0;

//     head = cmd;
//     pipe_all(cmd);

//     while (cmd)
//     {
//         pid = fork();
//         if (pid < 0)
//         {
//             perror("fork");
//             close_all_pipes(head);
//             return;
//         }
//         else if (pid == 0)
//         {
//             signal(SIGINT, SIG_DFL);
//             signal(SIGQUIT, handl_si);
//             if (prev && prev->pipe_out)
//                 dup2(prev->fd_pipe[0], 0);
//             if (cmd->pipe_out)
//                 dup2(cmd->fd_pipe[1], 1);
//             if(cmd->redirs != NULL)
//                 check_close_red(cmd, prev, list_env);

//             close_all_pipes(head);
//             if(cmd->redirs == NULL || cmd->redirs->fd != -1)
//                 execute_single_command(cmd, list_env, env);
//             // printf("{{{{{%d\n", cmd->data.exit_status);
//             last_status = cmd->data.exit_status;
//             exit(cmd->data.exit_status);
//         }
//         if(cmd->next == NULL)
//             last_pid = pid;

//         // Parent closes previous pipe ends
//         if (prev && prev->pipe_out)
//         {
//             close(prev->fd_pipe[0]);
//             close(prev->fd_pipe[1]);
//         }
//         prev = cmd;
//         cmd = cmd->next;
//     }
//     close_all_pipes(head);
//     	while ((pid = wait(&status)) > 0)
// 	{
// 		if (pid == last_pid)
// 		{
// 			if (WIFEXITED(status))
// 				last_status = WEXITSTATUS(status);
// 			else if (WIFSIGNALED(status))
// 			{
// 				int sig = WTERMSIG(status);
// 				if (sig == SIGQUIT)
// 					ft_putstr_fd("Quit: 3\n", 1);
// 				else if (sig == SIGINT)
// 					ft_putstr_fd("\n", 1);
// 				last_status = 128 + sig;
// 			}
//             // printf("...%d\n", last_status);
// 		}
// 	}
//     // while (wait(&status) > 0)
//     // {
//     //     if (WIFEXITED(status))
//     //         last_status = WEXITSTATUS(status);
//     //     else if (WIFSIGNALED(status))
//     //     {
//     //         int sig = WTERMSIG(status);
//     //         last_status = 128 + sig;
//     //     }
//     // }
//     // Set the exit status to the last command's status
//     // close_all_pipes(head);
//     // pid_t wpid;
//     // while ((pid = waitpid(pid, &status, 0)) > 0)
//     // {
//     //     if (WIFEXITED(status))
//     //     {
//     //         last_status = WEXITSTATUS(status);
//     //     }
//     // }
//     get_or_set(SET, last_status);
    
//     // // Set the exit status to the last command's status
//     // get_or_set(SET, last_status);

//     // while (wait(NULL) > 0)
//     //     ;
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anel-men <anel-men@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/07 12:07:21 by ayoakouh          #+#    #+#             */
/*   Updated: 2025/06/05 18:55:20 by anel-men         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"


int global_sig = 0;
int is_builtin(char **args)
{
	if(!args || !*args)
		return (1);
	if (strcmp(args[0], "cd") == 0)
		return (0);
	else if (strcmp(args[0], "echo") == 0)
		return (0);
	else if (strcmp(args[0], "unset") == 0)
		return (0);
	else if (strcmp(args[0], "export") == 0)
		return (0);
		else if (strcmp(args[0], "pwd") == 0)
			return (0);
		else if (strcmp(args[0], "env") == 0)
			return (0);
		else if (strcmp(args[0], "exit") == 0)
			return (0);
		else
			return (1);
}
// int get_or_set(int type, int status)
// {
// 	static int exit_status = 0;

// 	if (type == SET)
// 		exit_status = status; // rje3 dkre hadik kifch dkhlha m3a exit_status;
// 	return (exit_status); // always return the current value
// }
void excute_builting(t_cmd **command, t_env *env_list, char *env[])
{
	t_cmd	*cmd;
	int		status;

	cmd = *command;
	status = 0;

	if (strncmp("export", cmd->args[0], 6) == 0 && strlen(cmd->args[0]) == 6)
		status = ft_export(cmd->args, &env_list);
	else if (strncmp("env", cmd->args[0], 3) == 0 && strlen(cmd->args[0]) == 3)
		status = ft_env(*command, env_list);
	else if (strncmp("exit", cmd->args[0], 4) == 0 && strlen(cmd->args[0]) == 4)
	{
		status = ft_exit(cmd->args, cmd->data);
		// free_cmd_list(cmd);
	}
	else if (strncmp("unset", cmd->args[0], 5) == 0 && strlen(cmd->args[0]) == 5)
	{
		status = ft_unset(&env_list, cmd->args + 1);
	}
	else if (strncmp("echo", cmd->args[0], 4) == 0 && strlen(cmd->args[0]) == 4)
		status = echo(cmd->args);
	else if (strncmp("pwd", cmd->args[0], 3) == 0 && strlen(cmd->args[0]) == 3)
	{
		status = pwd(cmd->data);
	}
	else if (strncmp("cd", cmd->args[0], 2) == 0 && strlen(cmd->args[0]) == 2)
		status = ft_cd(cmd->args, &env_list, cmd->data);
	cmd->data.exit_status = get_or_set(SET, status);
}
void execute_single_command(t_cmd *cmd, t_env *list_env, char *env[])
{
	    // signal(SIGINT, SIG_IGN);
        // signal(SIGQUIT, SIG_IGN);
		if(!is_builtin(cmd->args))
		{
			if (list_env) 
			{
            cmd->data.new_pwd = get_value_env("PWD", &list_env);
			}
		else 
		{
            cmd->data.new_pwd = NULL;
        }
			excute_builting(&cmd, list_env, env);
			get_or_set(SET, cmd->data.exit_status);
			return ;
		}
		else
		{
			ft_excute_commands(cmd, &list_env);
			// if(global_sig == 1)
			// 	get_or_set(SET, 130);
			get_or_set(SET, cmd->data.exit_status);
		}
}
void handel_signal(int sig)
{
	struct termios infos;

	if (sig == SIGINT)
	{
		global_sig = sig;
		ft_putstr_fd("\n", 1);
		rl_on_new_line();
		rl_replace_line("", 0);
		rl_redisplay();
	}
	// else if (sig == SIGQUIT)
	// {
	// 	global_sig = 131;
	// 	ft_putstr_fd("Quit: 3\n", 2); // like bash does
	// 	rl_on_new_line();
	// 	rl_replace_line("", 0);
	// 	rl_redisplay();
	// }
	// else if (sig == SIGQUIT)
	// {
	// 	puts("kkk");
	// 	global_sig = 0;
	// 	rl_redisplay();
	// }
}
void check_sig(t_cmd *cmd)
{
	if(global_sig != 0)
	{
		if (global_sig == 2)
			global_sig = 1;
		cmd->data.exit_status = get_or_set(SET, global_sig);
		// global_sig = 0;
	}
}

// void check_line(t_cmd **command, t_env *env_list, char *env[])
// {
// 	 t_cmd	*cmd;
// 	  cmd = *command;
// 	  int fd_input ;
// 	  int fd_output ;

// 	// signal(SIGINT, handel_signal);
// 	// signal(SIGQUIT, SIG_IGN);
//     fd_input = dup(0);
// 	fd_output = dup(1);
// 	// check_sig(cmd);
// 	check_here_doc(*command, env_list);
// 	if (cmd->pipe_out)
// 	{
// 		dup2(fd_input, 0);
// 		dup2(fd_output, 1);
// 		close(fd_input);
// 		close(fd_output);
// 		ft_excute_mult_pipe(cmd, env_list, env);
// 		// get_or_set(SET, cmd->data.exit_status);
// 		return ;
// 	}
// 	else
// 	{
// 		if(cmd->redirs)
// 		{
// 			if(cmd->redirs->fd == -1)
// 			{
// 					dup2(fd_input, 0);
// 					dup2(fd_output, 1);
// 					close(fd_input);
// 					close(fd_output);
// 					cmd->data.exit_status = get_or_set(SET, 1);
// 					return ;
// 			}
// 			ft_redircte(cmd->redirs, env_list, *command);
// 			execute_single_command(cmd, env_list, env);
// 		}
// 		else
// 			execute_single_command(cmd, env_list, env);
// 	}
// 	// check_sig(cmd);
// 	dup2(fd_input, 0);
// 	dup2(fd_output, 1);
// 	close(fd_input);
// 	close(fd_output);
// }

void check_line(t_cmd **command, t_env *env_list, char *env[])
{
    t_cmd    *cmd;
    cmd = *command;
    int fd_input ;
    int fd_output ;

    // if ((*command)->redirs != NULL)
        check_here_doc(*command, env_list);
    fd_input = dup(0);
    fd_output = dup(1);
    if (cmd->pipe_out)
    {
        ft_excute_mult_pipe(cmd, env_list, env);
        get_or_set(SET, cmd->data.exit_status);
        dup2(fd_input, 0);
        dup2(fd_output, 1);
        close(fd_input);
        close(fd_output);
        return ;
    }
    else
    {
        if(cmd->redirs)
        {
            if(cmd->redirs->fd == -1)
            {
                    dup2(fd_input, 0);
                    dup2(fd_output, 1);
                    close(fd_input);
                    close(fd_output);
                    cmd->data.exit_status = get_or_set(SET, 1);
                    return ;
            }
            ft_redircte(cmd->redirs, env_list, *command);
            execute_single_command(cmd, env_list, env);
    dup2(fd_input, 0);
    dup2(fd_output, 1);
    close(fd_input);
    close(fd_output);
        }
        else
            execute_single_command(cmd, env_list, env);
    }
    dup2(fd_input, 0);
    dup2(fd_output, 1);
    close(fd_input);
    close(fd_output);
}

void add_one_shlvl(t_env *env)
{
    t_env *tmp = env;
    int shl_vl = 0;
    int found = 0;

    if (!env) 
        return;
    while (tmp) 
    {
        if (tmp->key && strcmp(tmp->key, "SHLVL") == 0)
        {
            found = 1;  // Mark that we found SHLVL
            if (tmp->value && tmp->value[0] != '\0')
            {
				// printf("SHLVL BEFOR : %s\n", tmp->value);
                shl_vl = atoi(tmp->value);
                free(tmp->value);
                tmp->value = NULL;
            }
            
            shl_vl++; 
            tmp->value = ft_itoa(shl_vl);
			// printf("SHLVL AFTER : %s\n", tmp->value);
            if (!tmp->value) 
                tmp->value = strdup("1");
            break;
        }
        tmp = tmp->next;
    }
    if (!found && env)
    {
        t_env *new_node = malloc(sizeof(t_env));
        if (!new_node)
            return;
            
        new_node->key = strdup("SHELVL");
        new_node->value = strdup("1");
        new_node->is_not_active = 0;
        new_node->next = NULL;
        tmp = env;
        while (tmp->next)
            tmp = tmp->next;
        tmp->next = new_node;
    }
}

void check_here_doc(t_cmd *cmd, t_env *env)
{
	 /* 0:<, 1:>, 2:>>, 3:<< */
	t_cmd *tmp;
	t_redir *tmp_redir;
	tmp_redir = NULL;
	tmp = cmd;
	int *fd;

	while (tmp)
	{
		tmp_redir = tmp->redirs;
		while (tmp_redir)
		{
			if (tmp_redir->type == 3)
				{
					fd = heredoc(tmp_redir->file, env, 0, tmp_redir->orig_token);
					// printf("%d\n", fd[1]);
					if (fd != NULL)
                	{
                    	tmp_redir->fd = fd[1];
                    	close(fd[0]);
						// free(fd[0]);
						// free(fd[1]);
						free(fd);
						
                	}
                	else
                	{
                    tmp_redir->fd = -1;
                }
				}
			tmp_redir = tmp_redir->next;
		}
		
		tmp = tmp->next;
	}
}


char *chenger_back(char *str)
{
    int i = 0;

    while (str && str[i])
    {
        if (str[i] == 10)
            str[i] = '\'';
        else if (str[i] == 11)
            str[i] = '\"';
        i++;
    }
    return str;
}

void change_back_cmd(t_cmd *cmd)
{
	t_cmd *tmp;
	int i = 0;
	tmp = cmd;

	while (tmp)
	{
		i = 0;
		while (tmp->args[i])
		{
			tmp->args[i] = chenger_back(tmp->args[i]);
			i++;
		}
		tmp->cmd = chenger_back(tmp->cmd);
		i = 0;
		t_redir *tp = tmp->redirs;
		while (tp)
		{
			tp->file = chenger_back(tp->file);
			tp = tp->next;
		}
		tmp = tmp->next;
	}
}
// void ff()
// {
// 	system("leaks minishell");
// }

int main(int argc, char *argv[], char *env[])
{
	t_token *token_list;
	t_env *env_struct = NULL;
	char *input;
	t_cmd *cmd = NULL;
	// atexit(ff);
	int exit_status = 0;
	// cmd->data.exit_status = 0;
	char *preprocessed_input;
		struct termios infos;
	(void)argc;
	(void)argv;
	if(!isatty(1) || !isatty(0))
	{
		exit(1);
	}
	env_struct = env_maker(env, &env_struct);
	if(!env_struct)
		env_null(&env_struct);
	add_one_shlvl(env_struct);
	token_list = NULL;
	tcgetattr(1, &infos);
	infos.c_lflag &= ~(ECHOCTL);
	tcsetattr(1, TCSANOW, &infos);
	while (1)
	{
		signal(SIGINT, handel_signal);
		signal(SIGQUIT, SIG_IGN);
		input = readline("minishell $> ");
		if (!input)
		{
			printf("exit\n");
			// free_env_struct(env_struct);
			// if (cmd) 
			// 	free_cmd_list(cmd);
    		// if (token_list) 
			// 	free_token_list(token_list);
			break ;
		}
		// if(global_sig != 0)
		// {
		// 	free(input);
		// 	continue;
		// }
		add_history(input);
		if (check_quotes(input))
		{
			exit_status = get_or_set(SET, 258); 
			free(input);
			continue;
		}
		preprocessed_input = preprocess_command(input); 
			free(input);
         if (!preprocessed_input)
		 {
			free(input);
            continue;
		 }
		token_list = tokin_list_maker(preprocessed_input);
		
		free(preprocessed_input);
		if (token_list && !error_pipi(token_list)  && !check_syntax_errors(token_list))
		{
			cmd = parser(token_list);
			free_token_list(token_list);
			expand_handle(cmd, env_struct, get_or_set(GET, 0));
			
			ambiguous_finder(cmd);
			process_quotes_for_cmd(cmd, 1);
			change_back_cmd(cmd);
			file_opener(cmd, env_struct);
			check_line(&cmd, env_struct, env);
			//expand_handle(cmd, env_struct, cmd->data.exit_status);
			
			free_cmd_list(cmd);
			global_sig = 0;
			
		}
		else if (error_pipi(token_list)  || check_syntax_errors(token_list))
			exit_status = get_or_set(SET, 258); 
		else if (token_list)
		{
			free_token_list(token_list);
		}

		// 	infos.c_lflag &= ~(ECHOCTL);
		// tcsetattr(1, TCSANOW, &infos);
	}
	
	free_env_struct(env_struct);
	return 0;
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pwd.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ayoakouh <ayoakouh@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/12 12:34:07 by ayoakouh          #+#    #+#             */
/*   Updated: 2025/05/19 15:56:08 by ayoakouh         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int pwd(t_data data)
{
	char	*pwd;
	int		status;

	status = 0;
	pwd = getcwd(NULL, 0);
	if(!pwd)
	{
		pwd = data.new_pwd;
		printf("%s\n", pwd);
		return(status);
	}
	else
		printf("%s\n", pwd);
	free(pwd);
	return (status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   r.c                                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anel-men <anel-men@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/09 16:33:44 by ayoakouh          #+#    #+#             */
/*   Updated: 2025/06/03 13:58:44 by anel-men         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include <sys/wait.h>
char *check_path(t_env **list)
{
    t_env *tmp;

    if (!list || !*list)
        return (NULL);
        
    tmp = *list;
    while (tmp)
    {
        if (!ft_strcmp(tmp->key, "PATH"))
            return (tmp->value);
        tmp = tmp->next;
    }
    return (NULL);
}

void    ft_free_split(char **str)
{
    int i = 0;

    while(str[i])
    {
        free(str[i]);
        i++;
    }
    free(str);
}
void    check_directory(t_cmd *cmd)
{
    struct stat err;
    if(stat(cmd->args[0], &err) == 0)
    {
        if (S_ISDIR(err.st_mode)) {
            write(2, "minishell: ", 11);
            write(2, cmd->args[0], ft_strlen(cmd->args[0]));
            write(2, ": is a directory\n", 17);
            cmd->data.exit_status = get_or_set(SET, 126);
            exit(126);
        }
    }
    else if(chdir(cmd->args[0]) == -1)
    {
        if (errno == 20)
        {
            write(2, "minishell: ", 11);
            write(2, cmd->args[0], ft_strlen(cmd->args[0]));
            write(2, ": Not a directory\n", 18);
            cmd->data.exit_status = get_or_set(SET, 126);
            exit(126);
        }
    }
}

void wait_for_children(t_cmd *cmd, pid_t child_pid)
{
    int status;

    status = 0;
    signal(SIGINT, SIG_IGN);
    signal(SIGQUIT, SIG_IGN);
    waitpid(child_pid, &status, 0);
    cmd->data.exit_status = WEXITSTATUS(status);
        if (WIFSIGNALED(status))
        {
            int sig = WTERMSIG(status);
            if (sig == SIGQUIT)
                ft_putstr_fd("Quit: 3\n", 1);
            else if (sig == SIGINT)
                ft_putstr_fd("\n", 1);
            cmd->data.exit_status = get_or_set(SET, 128 + sig);
            // printf("{{{%d\n", cmd->data.exit_status);
        }
}
void check_is_deroctory(t_cmd *cmd)
{
    int fd = open(cmd->args[0], O_DIRECTORY);
    if (fd == -1)
    {
        ft_putstr_fd("minishell: ", 2);
        write(2, cmd->args[0], ft_strlen(cmd->args[0]));
        cmd->data.exit_status = get_or_set(SET, 1);
        ft_putstr_fd(": Not a directory\n", 2);
        exit(1);
    }
    else
        close(fd);
}
void ft_print_error(t_cmd *cmd)
{
    // check_is_deroctory(cmd);
    ft_putstr_fd("minishell: ", 2);
    write(2, cmd->args[0], ft_strlen(cmd->args[0]));
    // puts("%d")
    if(errno == 2)
    {
        ft_putstr_fd(": No such file or directory\n", 2);
        cmd->data.exit_status = get_or_set(SET, 127);
        exit(127);
    }
    else if(errno == 13)
    {
        cmd->data.exit_status = get_or_set(SET, 126);
        ft_putstr_fd(": Permission denied\n", 2);
        exit(126);
    }
    else if(errno == 21)
    {
        cmd->data.exit_status = get_or_set(SET, 126);
        ft_putstr_fd(": Is a directory\n", 2);
        exit(126);
    }  
}
void handle_absolute_path(t_cmd *cmd, char **help)
{
    pid_t child_pid;
    int status = 0;
    child_pid = fork();
    if (child_pid == 0)
    {
         check_directory(cmd);
        if(access(cmd->args[0], X_OK) == 0)
        {
            execve(cmd->args[0], cmd->args, help);
            cmd->data.exit_status = get_or_set(SET, 0);
        }
        else
        {
            ft_print_error(cmd);
        }
    }
    else if (child_pid > 0)
    {
        wait_for_children(cmd, child_pid);
    }
    else
    {
        perror("fork");
        exit(0);
    }
}

void ft_execute_path_command(t_cmd *cmd, char **env_array, char **split_path)
{
    char *tmp;
    char *helper;
    int i = 0;
    while (split_path[i])
    {
        tmp = ft_strjoin(split_path[i], "/");
        helper = ft_strjoin(tmp, cmd->args[0]);
        free(tmp);
        if (!helper)
        {
            i++;
            continue;
        }
        if(!(access(helper, X_OK) == -1))
        {
            execve(helper, cmd->args, env_array);
            cmd->data.exit_status = get_or_set(SET, 0);
        }
        free(helper);
        i++;
    }
    write(2, "minishell: ", 11);
    write(2, cmd->args[0], ft_strlen(cmd->args[0]));
    write(2, ": command not found\n", 20);
    ft_free_split(split_path);
    cmd->data.exit_status = get_or_set(SET, 127);
    exit(127);
}
void ft_excute_commands(t_cmd *cmd, t_env **env_list)
{
    char **env_doble;
    char *path;
    char **split_path;
    pid_t child_pid;
    split_path = NULL;

    env_doble = convert_env_list(env_list);
    if(!cmd->args || !cmd->args[0])
    {
        free_split_str(env_doble);   
        return ;
    }
    if(ft_strchr(cmd->args[0], '/'))
    {
            handle_absolute_path(cmd, env_doble);
            free_split_str(env_doble);
            return ;
    }
    child_pid = fork();
    if(child_pid == 0)
    {
        signal(SIGINT, SIG_DFL);
        signal(SIGQUIT, SIG_DFL);
        path = check_path(env_list);
        if(!path)
        {
            if(ft_strcmp(cmd->args[0], "..") == 0)
            {
                write(2, "minishell: ", 11);
                write(2, cmd->args[0], ft_strlen(cmd->args[0]));
                write(2, ": is a directory\n", 17);
                cmd->data.exit_status = get_or_set(SET, 126);
                free_split_str(env_doble);
                exit(126);
            }     
            if(access(cmd->args[0], X_OK) != -1)
            {
                execve(cmd->args[0], cmd->args, env_doble);
                free_split_str(env_doble);
                exit(0);
            }
            else
            {
                ft_print_error(cmd);
                free_split_str(env_doble);
            }
        }
        else
        {
            split_path = ft_split(path, ':');
            if (!split_path)
            {
                free_split_str(env_doble);
                return ;
            }
            ft_execute_path_command(cmd, env_doble, split_path);
            ft_free_split(split_path);
            free_split_str(env_doble);
        }
    }
    else if(child_pid > 0)
    {
        wait_for_children(cmd, child_pid);
    }
    else if(child_pid < 0)
    {
        perror("fork failed");
        ft_free_split(split_path);
    }
    free_split_str(env_doble);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redrction.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: anel-men <anel-men@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/24 17:59:21 by ayoakouh          #+#    #+#             */
/*   Updated: 2025/06/04 20:25:09 by anel-men         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

// void intialize_struct(t_redir *list)
// {
//     t_redir *tmp = list;

//     tmp->type  = 0;
//     tmp->file = strdup("input.txt");
// }
// void ft_herdoc(t_redir *red, char *delimeter)
// {
//     t_redir *tmp;

//     tmp = red;
//     delimeter = tmp->file;
//     int fd = open("/tmp/.heredoc_tmp", O_CREAT | O_RDWR | O_TRUNC, 0664);

//     while(1)
//     {
//         char *line = readline("herdoc> ");
//         if(!ft_strcmp(delimeter, line))
//             break ;
//         write (fd, line, ft_strlen(line));
//         write (1, "\n", 1);
//         free(line);
//     }
//     // int infile = open("/tmp/.heredoc_tmp", O_RDONLY);

// }

void ft_redircte(t_redir *rederction, t_env *env, t_cmd *cmd)
{
    t_redir *tmp;

    tmp = rederction;

    while(tmp)
    {
        if(tmp->type == 0)
        {
            dup2(tmp->fd, 0);
            close(tmp->fd); 
        }
        else if (tmp->type == 1)
        {
            dup2(tmp->fd, 1);
            close(tmp->fd);
            
        }
        else if(tmp->type == 2 )
        {
            dup2(tmp->fd, 1);
            close (tmp->fd);
        }  
        else if (tmp->type == 3)
        {
          if (tmp->fd >= 0)
            {
                dup2(tmp->fd, 0);
                close(tmp->fd);  // Close after duplication
                    tmp->fd = -1;    // Mark as closed
            }
        }
        tmp = tmp->next;
    }
}

void free_cmd(t_cmd *cmd)
{
    t_redir *redir;
    t_redir *next_redir;
    
    if (cmd->cmd)
        free(cmd->cmd);
    
    if (cmd->args)
    {
        for (int i = 0; cmd->args[i]; i++)
            free(cmd->args[i]);
        free(cmd->args);
    }
    
    redir = cmd->redirs;
    while (redir)
    {
        next_redir = redir->next;
        if (redir->file)
            free(redir->file);
        free(redir);
        redir = next_redir;
    }
    free(cmd);
}

// int main(void)
// {
//     // Test case 1: Simple ls command with input redirection
//     printf("=== Test 1: ls with input redirection ===\n");
    
//     // Create command: ls -la
//     char **args = malloc(3 * sizeof(char *));
//     args[0] = strdup("ls");
//     args[1] = strdup("-la");
//     args[2] = NULL;
    
//     t_cmd *cmd = new_cmd("ls", args);
    
//     // Add input redirection
//     t_redir *redir = new_redir(0, "input.txt");
//     cmd->redirs = redir;
    
//     // Create a test input file
//     int fd = open("input.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
//     if (fd != -1) {
//         write(fd, "Test input file content\n", 23);
//         close(fd);
//     }
    
//     // Execute the redirection test
//     printf("Command: %s\n", cmd->cmd);
//     printf("Arguments: %s %s\n", cmd->args[0], cmd->args[1]);
//     printf("Redirection type: %d, file: %s\n", cmd->redirs->type, cmd->redirs->fd_file);
    
//     // Instead of actually executing (which would replace this process),
//     // we'll just print what would happen
//     printf("This would redirect input from %s and execute %s %s\n\n", 
//            cmd->redirs->fd_file, cmd->args[0], cmd->args[1]);

//     // Test case 2: Create a pipeline
//     printf("=== Test 2: Command pipeline ===\n");
    
//     // First command: ls -l
//     char **args1 = malloc(3 * sizeof(char *));
//     args1[0] = strdup("ls");
//     args1[1] = strdup("-l");
//     args1[2] = NULL;
    
//     t_cmd *cmd1 = new_cmd("ls", args1);
//     cmd1->pipe_out = 1; // This command pipes to the next
    
//     // Second command: grep ".c"
//     char **args2 = malloc(3 * sizeof(char *));
//     args2[0] = strdup("grep");
//     args2[1] = strdup(".c");
//     args2[2] = NULL;
    
//     t_cmd *cmd2 = new_cmd("grep", args2);
//     cmd2->pipe_out = 0; // End of pipeline
    
//     // Link commands
//     cmd1->next = cmd2;
    
//     // Print pipeline info
//     t_cmd *temp = cmd1;
//     int cmd_num = 1;
    
//     while(temp) {
//         printf("Command %d: %s\n", cmd_num, temp->cmd);
//         printf("  Arguments: ");
//         for(int i = 0; temp->args[i]; i++) {
//             printf("%s ", temp->args[i]);
//         }
//         printf("\n");
//         printf("  Pipe out: %d\n", temp->pipe_out);
        
//         temp = temp->next;
//         cmd_num++;
//     }
    
//     // Clean up
//     free_cmd(cmd);
    
//     // Free the pipeline
//     temp = cmd1;
//     while(temp) {
//         t_cmd *next = temp->next;
//         free_cmd(temp);
//         temp = next;
//     }
    
//     return 0;
// }
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signal.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ayoakouh <ayoakouh@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/26 12:06:41 by ayoakouh          #+#    #+#             */
/*   Updated: 2025/05/26 14:16:10 by ayoakouh         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

// #include "minishell.h"
// #include <signal.h>

// void handel_signal(int sig)
// {
//     ft_putstr_fd("\n", 1);
//     rl_on_new_line();
//     rl_replace_line("", 0);
//     rl_redisplay();  
// }